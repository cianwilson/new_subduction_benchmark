<?xml version='1.0' encoding='utf-8'?>
<terraferma_options>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="Mesh">
      <source name="File">
        <file>
          <string_value type="filename" lines="1">subduction</string_value>
        </file>
        <cell>
          <string_value lines="1">triangle</string_value>
        </cell>
      </source>
    </mesh>
  </geometry>
  <io>
    <output_base_name>
      <string_value lines="1">subduction_solid</string_value>
    </output_base_name>
    <visualization>
      <element name="P1">
        <family>
          <string_value lines="1">CG</string_value>
        </family>
        <degree>
          <integer_value rank="0">1</integer_value>
        </degree>
      </element>
    </visualization>
    <dump_periods>
      <visualization_period>
        <real_value rank="0">94.8640581818182</real_value>
        <comment>non-dim

t0 = h/v0 = 1330645161290.3225 s = 0.042166755183119145 Myr</comment>
      </visualization_period>
      <statistics_period>
        <real_value rank="0">94.8640581818182</real_value>
        <comment>non-dim

t0 = h/v0 = 1330645161290.3225 s = 0.042166755183119145 Myr</comment>
      </statistics_period>
      <detectors_period>
        <real_value rank="0">94.8640581818182</real_value>
      </detectors_period>
    </dump_periods>
    <detectors>
      <array name="Trench">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  global slab
  import numpy as np
  x0 = slab.x[0]
  y0 = slab.y[0]
  yf = slab.y[-1]
  ys = np.arange(y0, yf, -1.)
  coords = [(x0, y) for y in ys]
  return coords</string_value>
        </python>
      </array>
      <array name="Surface">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  global slab
  import numpy as np
  x0 = slab.x[0]
  xf = slab.x[-1]
  xs = np.arange(x0, xf, 1.)
  coords = [(x, 0.0) for x in xs]
  return coords</string_value>
        </python>
      </array>
      <array name="SlabLayer88">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['88']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer89">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['89']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer90">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['90']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer91">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['91']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer92">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['92']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer93">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['93']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer94">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['94']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer95">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['95']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer96">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['96']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer97">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['97']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer98">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['98']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer99">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['99']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer100">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['100']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer101">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['101']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer102">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['102']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer103">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['103']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer104">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['104']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer105">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['105']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer106">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['106']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer107">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['107']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer108">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['108']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer109">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['109']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer110">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['110']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer111">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['111']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="SlabLayer112">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  factor, offset = layers['112']
  nscoords = scoords + (factor*ssthicks + offset)*snormals
  nmask = (nscoords[0,:] &gt;= x0) &amp; (nscoords[0,:] &lt;= xf) &amp; (nscoords[1,:] &lt;= y0) &amp; (nscoords[1,:] &gt;= yf)
  return nscoords[:,nmask].transpose()</string_value>
        </python>
      </array>
      <array name="Right">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  global slab
  import numpy as np
  coords = [(400, -15), (400, -40)]
  return coords</string_value>
        </python>
      </array>
      <array name="Left">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  global slab
  import numpy as np
  coords = [(0, -50)]
  return coords</string_value>
        </python>
      </array>
    </detectors>
  </io>
  <nonlinear_systems>
    <relative_error>
      <real_value rank="0">5.e-6</real_value>
    </relative_error>
    <absolute_error>
      <real_value rank="0">5.e-9</real_value>
    </absolute_error>
    <max_iterations>
      <integer_value rank="0">100</integer_value>
    </max_iterations>
    <monitors/>
    <never_ignore_convergence_failures/>
  </nonlinear_systems>
  <global_parameters>
    <ufl>
      <string_value type="code" language="python3" lines="20">e0 = v0/h/365.25/24/60/60 # 1/s

x = SpatialCoordinate(us_e.cell())
deltazsurface = 0.0
z = -(x[1]+deltazsurface)

Tdim = Ts + T0*T + 0.3*z
Tdim_i = Ts + T0*T_i + 0.3*z
nexp = (n-1.)/n

# wedge viscosity:
edot = sym(grad(v))
eII = sqrt(0.5*inner(edot, edot))
# inverse dimensionless dislocation creep viscosity
inv_etadisl = eta0*invAdisl*exp(-Edisl/(n*R*Tdim))*(e0**nexp)*(eII**nexp)
# inverse dimensionless effective viscosity
inv_etaprime = inv_etadisl + eta0/etamax
# "harmonic mean" viscosity (actually twice the harmonic mean)
etaprime = 1./inv_etaprime

# slab viscosity:
edotp = sym(grad(vp))
eIIp = sqrt(0.5*inner(edotp, edotp))
# inverse dimensionless dislocation creep viscosity
inv_etadislp = eta0*invAdisl*exp(-Edisl/(n*R*Tdim))*(e0**nexp)*(eIIp**nexp)
# inverse dimensionless effective viscosity
inv_etaprimep = inv_etadislp + eta0/etamax
# "harmonic mean" viscosity (actually twice the harmonic mean)
etaprimep = 1./inv_etaprimep

# shear heating
plith = rho0*g*h*conditional(lt(z, deltazuc+deltazlc-deltazsurface), rhoc*z, rhoc*(deltazuc+deltazlc-deltazsurface) + rhom*(z-(deltazuc+deltazlc-deltazsurface)))
tauf = mu0*plith/tau0

Af1dim = Af1*1.e6  # MPa -&gt; Pa
Af2dim = Af2*1.e3  # kJ/mol -&gt; J/mol

fh2o = ah2o*Af1dim*exp(-(Af2dim + plith*Af3)/(R*Tdim))
fh2o_i = ah2o*Af1dim*exp(-(Af2dim + plith*Af3)/(R*Tdim_i))

Ashdim = Ash*(1.e6**-(rsh+nsh)) # MPa^-(rsh+nsh) s^-1 -&gt; Pa^-(rsh+nsh) s^-1
Eshdim = Esh*1.e3 # kJ/mol -&gt; J/mol

cdw = 2.5
deltav = (1.0 - Min(Max(-(x[1] + cd)/cdw, 0.0), 1.0))*vconv/v0

tauv_i = 0.5*((Ashdim**(-1./nsh))*((e0*h*deltav/wsh)**(1./nsh))*(fh2o_i**(-rsh/nsh))*exp((Eshdim+plith*Vsh)/(nsh*R*Tdim_i)))/tau0
tau_i = tauv_i*tanh(tauf/tauv_i)

# Domain information:
dx_uppercrust = dx(1)
dx_lowercrust = dx(2)
dx_crust = dx_uppercrust + dx_lowercrust
dx_wedgefluid = dx(3)
dx_wedgeright = dx(4)
dx_wedge = dx_wedgefluid + dx_wedgeright
dx_slab = dx(5)
dS_slabsh = dS((1,2))
dS_slab = dS((1,2,3,4))</string_value>
    </ufl>
    <python>
      <string_value type="code" language="python3" lines="20">import pickle
import numpy as np

# slab file
f = open("subduction.slab", 'rb')
slab = pickle.load(f)
f.close()

# bounding box
x0 = slab.x[0]
y0 = slab.y[0]
xf = slab.x[-1]
yf = slab.y[-1]

# vertices
scoords = [(slab.interpcurves[0].points[0].x, slab.interpcurves[0].points[0].y)]
scoords += [(curve.points[-1].x, curve.points[-1].y) for curve in slab.interpcurves]
scoords = np.asarray(scoords).transpose()  # transpose now to avoid some issues later

# normals
snormals = np.stack([-slab.cs(scoords[0,:], nu=1), np.ones(scoords.shape[1])], axis=0)
snormags = np.sqrt(np.sum(snormals**2, axis=0))
snormals = snormals/snormags

# sediment thicknesses
import sediment_thickness as st
z0 = st.z0
z15 = st.z15
y = scoords[1,:]
ssthicks = np.where(y&gt;y0, z0, np.where(y&lt;-15, z15, (z0-z15)*(y-y0)/(y0+15) + z0))

# set up layers
layer_names = [str(name) for name in range(88, 113)]
layer_factors = [0.0]*11 + [-0.5] + [-1.0]*13
layer_offsets = np.arange(9.5, 0.0, -1).tolist() + [0.0]*3 + [-0.15, -0.45, -1.4] + np.arange(-2.5, -11, -1).tolist()
layers = {layer_names[i]:(layer_factors[i], layer_offsets[i]) for i in range(len(layer_names))}</string_value>
    </python>
  </global_parameters>
  <system name="Stokes">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">us</string_value>
    </ufl_symbol>
    <field name="Velocity">
      <ufl_symbol name="global">
        <string_value lines="1">v</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <boundary_condition name="WedgeTop">
            <boundary_ids>
              <integer_value rank="1" shape="2">10 11</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <constant name="dim">
                  <real_value rank="1" dim1="dim" shape="2">0.0 0.0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="Slab">
            <boundary_ids>
              <integer_value rank="1" shape="4">1 2 3 4</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <cpp rank="1">
                  <members>
                    <string_value type="code" language="cpp" lines="20">GenericFunction_ptr slabt_ptr;
double vconv, v0, cd;</string_value>
                  </members>
                  <initialization>
                    <string_value type="code" language="cpp" lines="20">slabt_ptr = system()-&gt;fetch_coeff("SlabUnitTangent")-&gt;genericfunction_ptr(time());
GenericFunction_ptr v0_ptr = system()-&gt;fetch_coeff("VelocityScale")-&gt;genericfunction_ptr(time());
GenericFunction_ptr vconv_ptr = system()-&gt;fetch_coeff("ConvergenceSpeed")-&gt;genericfunction_ptr(time());
GenericFunction_ptr cd_ptr = system()-&gt;fetch_coeff("CouplingDepth")-&gt;genericfunction_ptr(time());

v0 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(v0_ptr));
vconv = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(vconv_ptr));
cd = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(cd_ptr));</string_value>
                  </initialization>
                  <eval>
                    <string_value type="code" language="cpp" lines="20">slabt_ptr-&gt;eval(values, x, cell);

for (int i = 0; i &lt; values.size(); ++i)
{
  values[i] = std::min(std::max(-(x[1]+cd)/2.5, 0.0), 1.0)*vconv*values[i]/v0;
}</string_value>
                  </eval>
                </cpp>
              </type>
            </sub_components>
          </boundary_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="Pressure">
      <ufl_symbol name="global">
        <string_value lines="1">p</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <field name="SlabVelocity">
      <ufl_symbol name="global">
        <string_value lines="1">vp</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <boundary_condition name="Slab">
            <boundary_ids>
              <integer_value rank="1" shape="4">1 2 3 4</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <cpp rank="1">
                  <members>
                    <string_value type="code" language="cpp" lines="20">GenericFunction_ptr slabt_ptr;
double vconv, v0;</string_value>
                  </members>
                  <initialization>
                    <string_value type="code" language="cpp" lines="20">slabt_ptr = system()-&gt;fetch_coeff("SlabUnitTangent")-&gt;genericfunction_ptr(time());
GenericFunction_ptr v0_ptr = system()-&gt;fetch_coeff("VelocityScale")-&gt;genericfunction_ptr(time());
GenericFunction_ptr vconv_ptr = system()-&gt;fetch_coeff("ConvergenceSpeed")-&gt;genericfunction_ptr(time());

v0 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(v0_ptr));
vconv = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(vconv_ptr));</string_value>
                  </initialization>
                  <eval>
                    <string_value type="code" language="cpp" lines="20">slabt_ptr-&gt;eval(values, x, cell);

for (int i = 0; i &lt; values.size(); ++i)
{
  values[i] = vconv*values[i]/v0;
}</string_value>
                  </eval>
                </cpp>
              </type>
            </sub_components>
          </boundary_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="SlabPressure">
      <ufl_symbol name="global">
        <string_value lines="1">pp</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <coefficient name="ConvergenceSpeed">
      <ufl_symbol name="global">
        <string_value lines="1">vconv</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.1</real_value>
              <comment>m/yr</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="TrenchDepth">
      <ufl_symbol name="global">
        <string_value lines="1">deltaztrench</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.0</real_value>
              <comment>non-dim

h = 1.e3 m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="CoastDistance">
      <ufl_symbol name="global">
        <string_value lines="1">deltaxcoast</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0</real_value>
              <comment>non-dim

h = 1.e3 m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="UpperCrustThickness">
      <ufl_symbol name="global">
        <string_value lines="1">deltazuc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">15</real_value>
              <comment>non-dim

h = 1.e3 m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="LowerCrustThickness">
      <ufl_symbol name="global">
        <string_value lines="1">deltazlc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">25</real_value>
              <comment>non-dim

h = 1.e3 m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="LengthScale">
      <ufl_symbol name="global">
        <string_value lines="1">h</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1000.0</real_value>
              <comment>m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="VelocityScale">
      <ufl_symbol name="global">
        <string_value lines="1">v0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.023716014545454547</real_value>
              <comment>m/yr

v0 = k0/rho0/cp0/h</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>The convergence speed.</comment>
    </coefficient>
    <coefficient name="ViscosityScale">
      <ufl_symbol name="global">
        <string_value lines="1">eta0</string_value>
        <comment>eta_inf in Kelemen et al.</comment>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.e21</real_value>
              <comment>Pas</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ViscosityCap">
      <ufl_symbol name="global">
        <string_value lines="1">etamax</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.e25</real_value>
              <comment>Pas</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ViscosityInversePreFactorDislocation">
      <ufl_symbol name="global">
        <string_value lines="1">invAdisl</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">3.452013559509262e-05</real_value>
              <comment>1./[28968.6 Pas^(1/n)]</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ViscosityActivationEnergyDislocation">
      <ufl_symbol name="global">
        <string_value lines="1">Edisl</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">540.e3</real_value>
              <comment>J/mol</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ViscosityStressExponentDislocation">
      <ufl_symbol name="global">
        <string_value lines="1">n</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">3.5</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="GasConstant">
      <ufl_symbol name="global">
        <string_value lines="1">R</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">8.3145</real_value>
              <comment>J/mol/K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="VelocityTheta">
      <ufl_symbol name="global">
        <string_value lines="1">thetav</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.5</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="SolidCourantNumber">
      <ufl_symbol name="global">
        <string_value lines="1">sc</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P0">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">0</integer_value>
            </degree>
          </element>
          <value name="Wedge" type="value">
            <region_ids>
              <integer_value rank="1" shape="2">3 4</integer_value>
            </region_ids>
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr v;

mutable double v_max, dt;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">v = system()-&gt;fetch_field("Velocity")-&gt;genericfunction_ptr(time());</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">const dolfin::Cell dcell((*system()-&gt;mesh()), cell.index);
dolfin::Array&lt;double&gt; v_values(2);
v-&gt;eval(v_values, x, cell);
v_max = std::max(std::abs(v_values[0]),std::abs(v_values[1]));
dt = bucket()-&gt;timestep();
values[0] = (v_max*dt)/(2*dcell.circumradius());</string_value>
              </eval>
            </cpp>
          </value>
          <value name="Slab" type="value">
            <region_ids>
              <integer_value rank="1" shape="1">5</integer_value>
            </region_ids>
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr v;

mutable double v_max, dt;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">v = system()-&gt;fetch_field("SlabVelocity")-&gt;genericfunction_ptr(time());</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">const dolfin::Cell dcell((*system()-&gt;mesh()), cell.index);
dolfin::Array&lt;double&gt; v_values(2);
v-&gt;eval(v_values, x, cell);
v_max = std::max(std::abs(v_values[0]),std::abs(v_values[1]));
dt = bucket()-&gt;timestep();
values[0] = (v_max*dt)/(2*dcell.circumradius());</string_value>
              </eval>
            </cpp>
          </value>
          <value name="Crust" type="value">
            <region_ids>
              <integer_value rank="1" shape="2">1 2</integer_value>
            </region_ids>
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_statistics/>
      </diagnostics>
    </coefficient>
    <coefficient name="SlabUnitTangent">
      <ufl_symbol name="global">
        <string_value lines="1">slabt</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <value name="WholeMesh" type="value">
            <python rank="1">
              <string_value type="code" language="python3" lines="20">def val(x):
  global slab, gmshtools
  try:
    return slab.unittangentx(x[0])
  except AssertionError:
    return [0.0,0.0]</string_value>
            </python>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="CouplingDepth">
      <ufl_symbol name="global">
        <string_value lines="1">cd</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">80.0</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <nonlinear_solver name="IsoviscousStokes">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">vvar = v_i
pvar = p_i
vpvar = vp_i
ppvar = pp_i

bv = inner(sym(grad(v_t)), 2*sym(grad(vvar))) - div(v_t)*pvar

r = bv*dx_wedge

bp = p_t*div(vvar)

r += bp*dx_wedge

bvp = inner(sym(grad(vp_t)), 2*sym(grad(vpvar))) - div(vp_t)*ppvar

r += bvp*dx_slab

bpp = pp_t*div(vpvar)

r += bpp*dx_slab</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J=derivative(r,us_i,us_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-10</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1.e-15</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <view_snes/>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="fieldsplit">
            <composite_type name="additive"/>
            <fieldsplit name="Stokes">
              <field name="Velocity">
                <region_ids>
                  <integer_value rank="1" shape="2">3 4</integer_value>
                </region_ids>
              </field>
              <field name="Pressure">
                <region_ids>
                  <integer_value rank="1" shape="2">3 4</integer_value>
                </region_ids>
              </field>
              <field name="SlabVelocity">
                <region_ids>
                  <integer_value rank="1" shape="1">5</integer_value>
                </region_ids>
              </field>
              <field name="SlabPressure">
                <region_ids>
                  <integer_value rank="1" shape="1">5</integer_value>
                </region_ids>
              </field>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="lu">
                  <factorization_package name="mumps"/>
                </preconditioner>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="EverythingElse">
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="none"/>
              </linear_solver>
            </fieldsplit>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="at_start"/>
    </nonlinear_solver>
    <nonlinear_solver name="LinearizedPicard">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">Tvar = T_i
vvar = v_i
pvar = p_i
vpvar = vp_i
ppvar = pp_i

bv = inner(sym(grad(v_t)), 2*etaprime*sym(grad(vvar))) - div(v_t)*pvar

r = bv*dx_wedge

bp = p_t*div(vvar)

r += bp*dx_wedge

bvp = inner(sym(grad(vp_t)), 2*etaprimep*sym(grad(vpvar))) - div(vp_t)*ppvar

r += bvp*dx_slab

bpp = pp_t*div(vpvar)

r += bpp*dx_slab</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J=derivative(r,us_i,us_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ksponly"/>
        <relative_error>
          <real_value rank="0">1.e-10</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1.e-10</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <view_snes/>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="fieldsplit">
            <composite_type name="additive"/>
            <fieldsplit name="Stokes">
              <field name="Velocity">
                <region_ids>
                  <integer_value rank="1" shape="2">3 4</integer_value>
                </region_ids>
              </field>
              <field name="Pressure">
                <region_ids>
                  <integer_value rank="1" shape="2">3 4</integer_value>
                </region_ids>
              </field>
              <field name="SlabVelocity">
                <region_ids>
                  <integer_value rank="1" shape="1">5</integer_value>
                </region_ids>
              </field>
              <field name="SlabPressure">
                <region_ids>
                  <integer_value rank="1" shape="1">5</integer_value>
                </region_ids>
              </field>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="lu">
                  <factorization_package name="mumps"/>
                </preconditioner>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="EverythingElse">
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="none"/>
              </linear_solver>
            </fieldsplit>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="in_timeloop"/>
    </nonlinear_solver>
    <functional name="SolidCourantNumberIntegral">
      <string_value type="code" language="python3" lines="20">int  = sc*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <exclude_from_statistics/>
    </functional>
    <functional name="SlabUnitTangentIntegral">
      <string_value type="code" language="python3" lines="20">int  = inner(slabt, slabt)*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <exclude_from_statistics/>
    </functional>
  </system>
  <system name="Temperature">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">uT</string_value>
    </ufl_symbol>
    <field name="PotentialTemperature">
      <ufl_symbol name="global">
        <string_value lines="1">T</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr Ti_ptr;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">Ti_ptr = system()-&gt;fetch_coeff("InitialTemperature")-&gt;genericfunction_ptr(time());</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">Ti_ptr-&gt;eval(values, x, cell);</string_value>
              </eval>
            </cpp>
          </initial_condition>
          <boundary_condition name="Top">
            <boundary_ids>
              <integer_value rank="1" shape="2">5</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0.0</real_value>
                  <comment>non-dim

T0 = 1 K</comment>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="Sides">
            <boundary_ids>
              <integer_value rank="1" shape="4">7 9 16 14</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <internal rank="0">
                  <algorithm name="Reference">
                    <coefficient name="InitialTemperature"/>
                  </algorithm>
                </internal>
              </type>
            </sub_components>
          </boundary_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <coefficient name="SurfaceHeatFlux">
      <ufl_symbol name="global">
        <string_value lines="1">qs</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">20.967741935483872</real_value>
              <comment>non-dim

q0 = Q0*h = k0*T0/h = 3.1e-3 W/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="SlabAge">
      <ufl_symbol name="global">
        <string_value lines="1">tslab</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">100.0</real_value>
              <comment>Myr</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="CrustalConductivity">
      <ufl_symbol name="global">
        <string_value lines="1">kc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.8064516129032258</real_value>
              <comment>non-dim

k0 = km = 3.1 W/m/K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="MantleConductivity">
      <ufl_symbol name="global">
        <string_value lines="1">km</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1</real_value>
              <comment>non-dim

k0 = km = 3.1 W/m/K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="UpperCrustHeatProduction">
      <ufl_symbol name="global">
        <string_value lines="1">Quc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.41935483870967744</real_value>
              <comment>non-dim

Q0 = k0*T0/h/h = 3.1e-6 W/m/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="LowerCrustHeatProduction">
      <ufl_symbol name="global">
        <string_value lines="1">Qlc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.08709677419354839</real_value>
              <comment>non-dim

Q0 = k0*T0/h/h = 3.1e-6 W/m/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="CrustalDensity">
      <ufl_symbol name="global">
        <string_value lines="1">rhoc</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.833333333333333</real_value>
              <comment>non-dim

rho0 = 3300 kg/m/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="MantleDensity">
      <ufl_symbol name="global">
        <string_value lines="1">rhom</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1</real_value>
              <comment>non-dim

rho0 = 3300 kg/m/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="IsobaricHeatCapacity">
      <ufl_symbol name="global">
        <string_value lines="1">cp</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1</real_value>
              <comment>non-dim

cp0 = 1250 J/kg/K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="TemperatureScale">
      <ufl_symbol name="global">
        <string_value lines="1">T0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.0</real_value>
              <comment>K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="SurfaceTemperature">
      <ufl_symbol name="global">
        <string_value lines="1">Ts</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">273.0</real_value>
              <comment>K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="MantlePotentialTemperature">
      <ufl_symbol name="global">
        <string_value lines="1">Tm</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1350</real_value>
              <comment>non-dim

T0 = 1 K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_statistics/>
      </diagnostics>
    </coefficient>
    <coefficient name="TemperatureTheta">
      <ufl_symbol name="global">
        <string_value lines="1">thetaT</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.5</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="InitialTemperature">
      <ufl_symbol name="global">
        <string_value lines="1">Ti</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <value name="Wedge" type="value">
            <region_ids>
              <integer_value rank="1" shape="4">1 2 3 4</integer_value>
            </region_ids>
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">double kc, km, quc, qlc, qm, Quc, Qlc, Qm, Tlc, Tuc, Tm, Ts, deltazc, deltazuc, deltaztrench, deltaxcoast;
mutable double deltaz, deltazsurface;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr Quc_ptr = system()-&gt;fetch_coeff("UpperCrustHeatProduction")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Qlc_ptr = system()-&gt;fetch_coeff("LowerCrustHeatProduction")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltazuc_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("UpperCrustThickness")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltazlc_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("LowerCrustThickness")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltaztrench_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("TrenchDepth")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltaxcoast_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("CoastDistance")-&gt;genericfunction_ptr(time());
GenericFunction_ptr quc_ptr = system()-&gt;fetch_coeff("SurfaceHeatFlux")-&gt;genericfunction_ptr(time());
GenericFunction_ptr kc_ptr = system()-&gt;fetch_coeff("CrustalConductivity")-&gt;genericfunction_ptr(time());
GenericFunction_ptr km_ptr = system()-&gt;fetch_coeff("MantleConductivity")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Tm_ptr = system()-&gt;fetch_coeff("MantlePotentialTemperature")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Ts_ptr = system()-&gt;fetch_coeff("SurfaceTemperature")-&gt;genericfunction_ptr(time());

deltazuc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltazuc_ptr));
double deltazlc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltazlc_ptr));
deltaztrench = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaztrench_ptr));
deltaxcoast = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaxcoast_ptr));
Quc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Quc_ptr));
Qlc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Qlc_ptr));
quc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(quc_ptr));
kc = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(kc_ptr));

km = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(km_ptr));
qlc = quc - deltazuc*Quc;
qm = qlc - deltazlc*Qlc;
Tm = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Tm_ptr));
Ts = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Ts_ptr));

Tuc = deltazuc*quc/kc - Quc*(deltazuc*deltazuc)/2.0/kc;
Tlc = Tuc + deltazlc*qlc/kc - Qlc*(deltazlc*deltazlc)/2.0/kc;
deltazc = deltazuc + deltazlc;</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">deltazsurface = 0.0;

if (-(x[1]+deltazsurface) &lt; deltazuc)
{
  deltaz = -(x[1] + deltazsurface);
  values[0] = deltaz*quc/kc - Quc*(deltaz*deltaz)/2.0/kc;
}
else if (-(x[1]+deltazsurface) &lt; deltazc)
{
  deltaz = -(x[1] + deltazsurface + deltazuc);
  values[0] = Tuc + deltaz*qlc/kc - Qlc*deltaz*deltaz/2.0/kc;
}
else
{
  deltaz = -(x[1] + deltazsurface + deltazc);
  values[0] = Tlc + deltaz*qm/km;
}

if (values[0] &gt;= Tm)
{
  values[0] = Tm;
}</string_value>
              </eval>
              <time_independent/>
            </cpp>
          </value>
          <value name="Slab" type="value">
            <region_ids>
              <integer_value rank="1" shape="1">5</integer_value>
            </region_ids>
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">mutable double deltazsurface;
double hthermal, deltaztrench, deltaxcoast, Tm, Ts;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr km_ptr = system()-&gt;fetch_coeff("MantleConductivity")-&gt;genericfunction_ptr(time());
GenericFunction_ptr rhom_ptr = system()-&gt;fetch_coeff("MantleDensity")-&gt;genericfunction_ptr(time());
GenericFunction_ptr cp_ptr = system()-&gt;fetch_coeff("IsobaricHeatCapacity")-&gt;genericfunction_ptr(time());
GenericFunction_ptr tslab_ptr = system()-&gt;fetch_coeff("SlabAge")-&gt;genericfunction_ptr(time());
GenericFunction_ptr v0_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("VelocityScale")-&gt;genericfunction_ptr(time());
GenericFunction_ptr h_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("LengthScale")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Tm_ptr = system()-&gt;fetch_coeff("MantlePotentialTemperature")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Ts_ptr = system()-&gt;fetch_coeff("SurfaceTemperature")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltaztrench_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("TrenchDepth")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltaxcoast_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("CoastDistance")-&gt;genericfunction_ptr(time());

double cp = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(cp_ptr));
double km = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(km_ptr));
double rhom = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(rhom_ptr));
double tslab = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(tslab_ptr));
double v0 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(v0_ptr));
double h = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(h_ptr));

Tm = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Tm_ptr));
Ts = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Ts_ptr));
deltaztrench = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaztrench_ptr));
deltaxcoast = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaxcoast_ptr));

double kappam = km/rhom/cp;
hthermal = 2*std::sqrt(kappam*tslab*v0*1.e6/h);</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">deltazsurface = 0.0;

values[0] = Tm*std::erf(-(x[1]+deltazsurface)/hthermal);</string_value>
              </eval>
              <time_independent/>
            </cpp>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
      </diagnostics>
    </coefficient>
    <coefficient name="ShearHeatingStressScale">
      <ufl_symbol name="global">
        <string_value lines="1">tau0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">4125000</real_value>
              <comment>Pa

tau0 = rho0*cp0*T0</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="FrictionCoefficient">
      <ufl_symbol name="global">
        <string_value lines="1">mu0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.0</real_value>
              <comment>non-dim</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="DensityScale">
      <ufl_symbol name="global">
        <string_value lines="1">rho0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">3300</real_value>
              <comment>kg/m/m/m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="GravityMagnitude">
      <ufl_symbol name="global">
        <string_value lines="1">g</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">9.80665</real_value>
              <comment>m/s/s</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ShearHeatingStressPrefactor">
      <ufl_symbol name="global">
        <string_value lines="1">Ash</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">2.e-4</real_value>
              <comment>MPa^-(rsh+nsh) s^-1

We don't include grain size dependency here yet so no m.</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ShearHeatingZoneThickness">
      <ufl_symbol name="global">
        <string_value lines="1">wsh</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">500</real_value>
              <comment>m</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ShearHeatingStressExponent">
      <ufl_symbol name="global">
        <string_value lines="1">nsh</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.9</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ShearHeatingActivationEnthalpy">
      <ufl_symbol name="global">
        <string_value lines="1">Esh</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">141</real_value>
              <comment>kJ/mol</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ShearHeatingActivationVolume">
      <ufl_symbol name="global">
        <string_value lines="1">Vsh</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.0</real_value>
              <comment>m^3/mol</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="WaterActivity">
      <ufl_symbol name="global">
        <string_value lines="1">ah2o</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.0</real_value>
              <comment>non-dim

no effect unless rsh /= 0</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="WaterFugacityA1">
      <ufl_symbol name="global">
        <string_value lines="1">Af1</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">5521</real_value>
              <comment>MPa

no effect unless rsh /= 0</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="WaterFugacityA2">
      <ufl_symbol name="global">
        <string_value lines="1">Af2</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">31.28</real_value>
              <comment>kJ/mol

no effect unless rsh /= 0</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="WaterFugacityA3">
      <ufl_symbol name="global">
        <string_value lines="1">Af3</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">-2.009e-5</real_value>
              <comment>m^3/mol

no effect unless rsh /= 0</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="WaterFugacityExponent">
      <ufl_symbol name="global">
        <string_value lines="1">rsh</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0</real_value>
              <comment>non-dim</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="ConductivityScale">
      <ufl_symbol name="global">
        <string_value lines="1">k0</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">3.1</real_value>
              <comment>W/m/K</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="Temperature">
      <ufl_symbol name="global">
        <string_value lines="1">Tfull</string_value>
      </ufl_symbol>
      <type name="Expression">
        <rank name="Scalar" rank="0">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <value name="WholeMesh" type="value">
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr T_ptr;
mutable double z, deltazsurface;
double T0, Ts, deltaztrench, deltaxcoast;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">T_ptr = system()-&gt;fetch_field("PotentialTemperature")-&gt;genericfunction_ptr(time());

GenericFunction_ptr T0_ptr = system()-&gt;fetch_coeff("TemperatureScale")-&gt;genericfunction_ptr(time());
GenericFunction_ptr Ts_ptr = system()-&gt;fetch_coeff("SurfaceTemperature")-&gt;genericfunction_ptr(time());

T0 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(T0_ptr));
Ts = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(Ts_ptr));

GenericFunction_ptr deltaztrench_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("TrenchDepth")-&gt;genericfunction_ptr(time());
GenericFunction_ptr deltaxcoast_ptr = bucket()-&gt;fetch_system("Stokes")-&gt;fetch_coeff("CoastDistance")-&gt;genericfunction_ptr(time());

deltaztrench = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaztrench_ptr));
deltaxcoast = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(deltaxcoast_ptr));</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">deltazsurface = 0.0;
z = -(x[1]+deltazsurface);

T_ptr-&gt;eval(values, x, cell);
values[0] = T0*values[0] + 0.3*z;</string_value>
              </eval>
            </cpp>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </coefficient>
    <nonlinear_solver name="TemperatureNoShearHeating">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">Tvar = T_i
vvar = v_i
vpvar = vp_i

bT_uppercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Quc
bT_lowercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Qlc
bT_wedge = rhom*cp*T_t*inner(vvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))
bT_slab  = rhom*cp*T_t*inner(vpvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))

r  = bT_uppercrust*dx_uppercrust
r += bT_lowercrust*dx_lowercrust
r += bT_wedge*dx_wedge
r += bT_slab*dx_slab</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J=derivative(r,uT_i,uT_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-10</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1.e-15</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <view_snes/>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="at_start"/>
    </nonlinear_solver>
    <nonlinear_solver name="TemperatureShearHeating">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">Tvar = T_i
vvar = v_i
vpvar = vp_i

bT_uppercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Quc
bT_lowercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Qlc
bT_wedge = rhom*cp*T_t*inner(vvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))
bT_slab  = rhom*cp*T_t*inner(vpvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))

r  = bT_uppercrust*dx_uppercrust
r += bT_lowercrust*dx_lowercrust
r += bT_wedge*dx_wedge
r += bT_slab*dx_slab
r -= (T_t*tau_i*deltav)('+')*dS_slabsh</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J=derivative(r,uT_i,uT_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-10</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1.e-15</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <view_snes/>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="at_start"/>
    </nonlinear_solver>
    <nonlinear_solver name="Newton">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">Tvar = T_i
vvar = v_i
vpvar = vp_i

bT_uppercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Quc
bT_lowercrust = inner(grad(T_t), kc*grad(Tvar)) - T_t*Qlc
bT_wedge = rhom*cp*T_t*inner(vvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))
bT_slab  = rhom*cp*T_t*inner(vpvar, grad(Tvar)) + inner(grad(T_t), km*grad(Tvar))

r  = bT_uppercrust*dx_uppercrust
r += bT_lowercrust*dx_lowercrust
r += bT_wedge*dx_wedge
r += bT_slab*dx_slab
r -= (T_t*tau_i*deltav)('+')*dS_slabsh</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J=derivative(r,uT_i,uT_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-10</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1.e-10</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <view_snes/>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="in_timeloop"/>
    </nonlinear_solver>
    <functional name="InitialTemperatureIntegral">
      <string_value type="code" language="python3" lines="20">int  = Ti*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <exclude_from_statistics/>
    </functional>
  </system>
  <system name="Viscosity">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">uvisc</string_value>
    </ufl_symbol>
    <field name="Viscosity">
      <ufl_symbol name="global">
        <string_value lines="1">visc</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P0">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">0</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">1.e4</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">r  = visc_t*(visc_i - etaprime)*dx_wedge
r += visc_t*(visc_i - etaprimep)*dx_slab</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(r, uvisc_i, uvisc_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">6</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-6</real_value>
        </relative_error>
        <max_iterations>
          <integer_value rank="0">1</integer_value>
        </max_iterations>
        <monitors/>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="fieldsplit">
            <composite_type name="additive"/>
            <fieldsplit name="NotCrust">
              <field name="Viscosity">
                <region_ids>
                  <integer_value rank="1" shape="3">3 4 5</integer_value>
                </region_ids>
              </field>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="jacobi"/>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="EverythingElse">
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="none"/>
              </linear_solver>
            </fieldsplit>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="with_diagnostics"/>
    </nonlinear_solver>
  </system>
  <system name="SlabStress">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">usigma</string_value>
    </ufl_symbol>
    <field name="Normal">
      <ufl_symbol name="global">
        <string_value lines="1">nsigman</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="Tangential">
      <ufl_symbol name="global">
        <string_value lines="1">tsigman</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="ShearHeating">
      <ufl_symbol name="global">
        <string_value lines="1">taush</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="StrainRate">
      <ufl_symbol name="global">
        <string_value lines="1">edotsh</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">fn = FacetNormal(usigma_e.cell())
ft = as_vector([-fn[1], fn[0]])

kup = as_vector([0, 1])
kdotn = dot(kup, fn)
kndn = 0.5*(kdotn - abs(kdotn))
fdn = -kndn/abs(kdotn) # not safe to use on vertical facets

sigman = dot(2*eta0*e0*1.e-6*etaprime*edot, fn) # output in MPa

snsigman = ((nsigman_t*(nsigman_i - dot(fn, sigman))*fdn)('+') + \
            (nsigman_t*(nsigman_i - dot(fn, sigman))*fdn)('-'))*dS_slab
stsigman = ((tsigman_t*(tsigman_i - dot(ft, sigman))*fdn)('+') + \
            (tsigman_t*(tsigman_i - dot(ft, sigman))*fdn)('-'))*dS_slab
staush   = (taush_t*(taush_i - tau0*tau_i*1.e-6))('+')*dS_slabsh  # MPa
sedotsh  = (edotsh_t*(edotsh_i - e0*h*deltav/wsh))('+')*dS_slab

r = snsigman + stsigman + staush + sedotsh</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(r, usigma_i, usigma_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_degree>
          <integer_value rank="0">4</integer_value>
        </quadrature_degree>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-6</real_value>
        </relative_error>
        <max_iterations>
          <integer_value rank="0">10</integer_value>
        </max_iterations>
        <monitors>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="fieldsplit">
            <composite_type name="additive"/>
            <fieldsplit name="Slab">
              <field name="Normal">
                <boundary_ids>
                  <integer_value rank="1" shape="4">1 2 3 4</integer_value>
                </boundary_ids>
              </field>
              <field name="Tangential">
                <boundary_ids>
                  <integer_value rank="1" shape="4">1 2 3 4</integer_value>
                </boundary_ids>
              </field>
              <field name="ShearHeating">
                <boundary_ids>
                  <integer_value rank="1" shape="2">1 2</integer_value>
                </boundary_ids>
              </field>
              <field name="StrainRate">
                <boundary_ids>
                  <integer_value rank="1" shape="4">1 2 3 4</integer_value>
                </boundary_ids>
              </field>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="lu">
                  <factorization_package name="mumps"/>
                </preconditioner>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="EverythingElse">
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="none"/>
              </linear_solver>
            </fieldsplit>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="with_diagnostics"/>
    </nonlinear_solver>
  </system>
  <system name="TemperatureFlux">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">uTflux</string_value>
    </ufl_symbol>
    <field name="Diffusive">
      <ufl_symbol name="global">
        <string_value lines="1">kgradT</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="P1DG">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
        </rank>
      </type>
      <diagnostics>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">bc = inner(kgradT_t, kgradT_i - (k0*T0/h)*kc*grad(Tfull))
bm = inner(kgradT_t, kgradT_i - (k0*T0/h)*km*grad(Tfull))

r  = bc*dx_uppercrust
r += bc*dx_lowercrust
r += bm*dx_slab
r += bm*dx_wedge</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">r</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(r, uTflux_i, uTflux_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1.e-6</real_value>
        </relative_error>
        <max_iterations>
          <integer_value rank="0">1</integer_value>
        </max_iterations>
        <monitors/>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="with_diagnostics"/>
    </nonlinear_solver>
  </system>
</terraferma_options>
